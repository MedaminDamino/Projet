@page "/discover"
@implements IDisposable
@inject HttpClient Http
@using BookDashboardBlazor.Services
@inject ReviewService ReviewService
@inject AuthenticationStateProvider AuthStateProvider
@inject NavigationManager Nav

<PageTitle>Discover Books</PageTitle>

<style>
    .user-rating .star-rating {
        gap: 0.2rem;
    }

    .user-rating .star-rating .bi {
        font-size: 1.4rem;
        transition: color 0.2s ease;
    }
</style>

<div class="position-fixed top-0 end-0 p-3" style="z-index: 1080;">
    <Toast Visible="showRatingToast"
           Type="ratingToastType"
           Message="@(ratingToastMessage ?? string.Empty)"
           OnClose="HideRatingToast"
           CssClass="shadow" />
</div>

<div class="discover-page">
    <div class="container-xxl">
        <!-- Hero / Search -->
        <div class="discover-hero my-4">
            <div class="hero-surface shadow-lg">
                <span class="hero-label">Discover</span>
                <h1 class="hero-title">Discover Books</h1>
                <p class="hero-subtitle">Browse curated titles and filter by genre, rating, or recency.</p>
                <div class="hero-search">
                    <i class="bi bi-search"></i>
                    <input class="form-control hero-input"
                           placeholder="Search by title or author..."
                           value="@searchQuery"
                           @oninput="OnSearchChanged" />
                </div>
            </div>
        </div>

        <div class="row g-4">
            <!-- Filters -->
            <div class="col-12 col-lg-3">
                <div class="card shadow-sm border-0 h-100 sticky-filters">
                    <div class="card-body">
                        <div class="d-flex justify-content-between align-items-center mb-3">
                            <h6 class="mb-0 text-uppercase text-muted fw-semibold small">Filters</h6>
                            <span class="badge bg-light text-secondary border">Live</span>
                        </div>

                        <div class="mb-4">
                            <label class="form-label small fw-semibold text-muted">Genres</label>
                            <div class="d-grid gap-2 filter-list">
                                @if (genres == null || !genres.Any())
                                {
                                    <span class="text-muted small">Loading genres...</span>
                                }
                                else
                                {
                                    @foreach (var genre in genres)
                                    {
                                        <div class="form-check">
                                            <input class="form-check-input" type="checkbox" id="genre-@genre.GenreId"
                                                   checked="@selectedGenres.GetValueOrDefault(genre.GenreId)"
                                                   @onchange="e => OnGenreToggled(genre.GenreId, e)" />
                                            <label class="form-check-label" for="genre-@genre.GenreId">
                                                @genre.GenreName
                                            </label>
                                        </div>
                                    }
                                }
                            </div>
                        </div>

                        <div class="mb-3">
                            <label class="form-label small fw-semibold text-muted">Minimum rating</label>
                            <select class="form-select" @bind="MinRating">
                                <option value="0">Any rating</option>
                                <option value="4">4+ stars</option>
                                <option value="3">3+ stars</option>
                                <option value="2">2+ stars</option>
                                <option value="1">1+ stars</option>
                            </select>
                        </div>

                        <div class="mb-3">
                            <label class="form-label small fw-semibold text-muted">Sort by</label>
                            <select class="form-select" @bind="SortOption">
                                <option value="trending">Trending</option>
                                <option value="newest">Newest</option>
                                <option value="rating">Top rated</option>
                                <option value="title">A-Z</option>
                            </select>
                        </div>

                        <button class="btn btn-primary w-100" @onclick="ApplyFilters">
                            Apply filters
                        </button>
                    </div>
                </div>
            </div>

            <!-- Books grid -->
            <div class="col-12 col-lg-9">
                @if (isLoading)
                {
                    <div class="row g-4 row-cols-1 row-cols-sm-2 row-cols-md-3 row-cols-xl-4">
                        @for (int i = 0; i < 8; i++)
                        {
                            <div class="col">
                                <div class="card h-100 shadow-sm placeholder-card">
                                    <div class="ratio ratio-3x4 placeholder-glow">
                                        <div class="placeholder w-100 h-100"></div>
                                    </div>
                                    <div class="card-body">
                                        <div class="placeholder-glow">
                                            <div class="placeholder col-8 mb-2"></div>
                                            <div class="placeholder col-5 mb-2"></div>
                                            <div class="placeholder col-10 mb-3"></div>
                                            <div class="placeholder col-6"></div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        }
                    </div>
                }
                else if (books == null || !books.Any())
                {
                    <div class="card border-0 shadow-sm text-center p-5">
                        <div class="card-body">
                            <i class="bi bi-search text-muted display-4 mb-3"></i>
                            <h5 class="fw-semibold mb-2">No books found</h5>
                            <p class="text-muted mb-0">Try adjusting your search or filters to see more results.</p>
                        </div>
                    </div>
                }
                else
                {
                    <div class="row g-4 row-cols-1 row-cols-sm-2 row-cols-md-3 row-cols-xl-4">
                        @foreach (var book in books)
                        {
                            <div class="col">
                                <div class="card h-100 shadow-sm book-card">
                                    <div class="ratio ratio-3x4 bg-light position-relative overflow-hidden">
                                        <img src="@ResolveImageUrl(book.CoverImageUrl)"
                                             alt="@book.Title cover"
                                             class="book-cover"
                                             onerror="@ImageErrorFallbackJs"
                                             style="object-fit:cover; width:100%; height:100%; display:block;" />
                                    </div>
                                    <div class="card-body d-flex flex-column">
                                        <div class="d-flex align-items-start justify-content-between gap-2">
                                            <h6 class="mb-1 fw-semibold text-truncate" title="@book.Title">@book.Title</h6>
                                            <span class="badge bg-soft-primary text-primary">@GetGenreName(book.GenreId)</span>
                                        </div>
                                        <p class="text-muted small mb-2">@GetAuthorName(book.AuthorId)</p>
                                        <p class="text-secondary small flex-grow-1 overflow-hidden">
                                            @Truncate(book.Description, 110)
                                        </p>
                                        
                                        @{ var userRating = GetUserRating(book.BookId); }
                                        <div class="user-rating my-2 d-flex justify-content-center align-items-center gap-1 flex-wrap"
                                             style="min-height: 32px;"
                                             title="@GetRatingTooltip(userRating)">
                                            <StarRating Value="@userRating"
                                                        ValueChanged="@((int rating) => SetRatingAsync(book.BookId, rating))" />
                                        </div>

                                        <div class="d-flex align-items-center justify-content-between mt-auto">
                                            <div class="d-flex align-items-center gap-2 text-muted small">
                                                <i class="bi bi-star-fill text-warning"></i>
                                                <span>@book.AverageRating.ToString("0.0")</span>
                                                <span>&middot;</span>
                                                <span>@book.PublishYear</span>
                                            </div>
                                            <button class="btn btn-outline-primary btn-sm" @onclick="() => HandleAddToList(book)">
                                                <i class="bi bi-plus-lg me-1"></i> Add
                                            </button>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        }
                    </div>

                    @if (hasMoreBooks)
                    {
                        <div class="text-center mt-4">
                            <button class="btn btn-primary px-4" @onclick="LoadMoreBooks" disabled="@isLoadingMore">
                                @if (isLoadingMore)
                                {
                                    <LoadingSpinner Inline="true" ShowLabel="false" Size="18" CssClass="me-2" />
                                    <span>Loading...</span>
                                }
                                else
                                {
                                    <span>Load more</span>
                                }
                            </button>
                        </div>
                    }
                }
            </div>
        </div>
    </div>
</div>

@code {
    private List<BookDiscover> books = new();
    private List<Author> authors = new();
    private List<Genre> genres = new();
    private Dictionary<int, bool> selectedGenres = new();
    private Dictionary<int, int> _userRatings = new();
    private bool isAuthenticated;
    private bool _hasShownLoginReminder;
    private const string LoginRequiredMessage = "Login to rate this book.";
    private const string PlaceholderImage = "/images/book-placeholder.svg";
    private string ImageErrorFallbackJs => $"this.onerror=null; this.src='{PlaceholderImage}';";
    private bool showRatingToast;
    private string? ratingToastMessage;
    private ToastType ratingToastType = ToastType.Success;

    private string searchQuery = string.Empty;
    private int _minRating = 0;
    private string _sortOption = "trending";
    private bool isLoading = true;
    private bool isLoadingMore = false;
    private bool hasMoreBooks = true;
    private int currentPage = 1;
    private const int PageSize = 20;
    private System.Timers.Timer? _debounceTimer;

    private int MinRating
    {
        get => _minRating;
        set
        {
            if (_minRating != value)
            {
                _minRating = value;
                _ = LoadBooks();
            }
        }
    }

    private string SortOption
    {
        get => _sortOption;
        set
        {
            if (_sortOption != value)
            {
                _sortOption = value;
                _ = LoadBooks();
            }
        }
    }

    protected override async Task OnInitializedAsync()
    {
        AuthStateProvider.AuthenticationStateChanged += HandleAuthenticationStateChanged;

        var authState = await AuthStateProvider.GetAuthenticationStateAsync();
        isAuthenticated = authState.User.Identity?.IsAuthenticated ?? false;

        await LoadGenresAndAuthors();
        await LoadBooks();
        
        // Ensure user ratings are loaded after books are loaded
        if (isAuthenticated && books.Any())
        {
            await LoadUserRatings(books);
        }
    }

    protected override async Task OnParametersSetAsync()
    {
        // Handle navigation back to the page
        var authState = await AuthStateProvider.GetAuthenticationStateAsync();
        var wasAuthenticated = isAuthenticated;
        isAuthenticated = authState.User.Identity?.IsAuthenticated ?? false;

        // If user logged out, clear ratings
        if (!isAuthenticated && wasAuthenticated)
        {
            ClearAllRatings();
            await InvokeAsync(StateHasChanged);
            return;
        }

        // If user is authenticated, ensure books are loaded and ratings are loaded
        if (isAuthenticated)
        {
            // If books haven't been loaded yet, load them first
            if (!books.Any() && !isLoading)
            {
                await LoadBooks();
            }
            // If books are already loaded, reload ratings to ensure they're current
            else if (books.Any())
            {
                await LoadUserRatings(books);
            }
        }
    }

    private async void HandleAuthenticationStateChanged(Task<AuthenticationState> task)
    {
        var authState = await task;
        var newIsAuthenticated = authState.User.Identity?.IsAuthenticated ?? false;

        if (newIsAuthenticated == isAuthenticated)
        {
            return;
        }

        isAuthenticated = newIsAuthenticated;
        _hasShownLoginReminder = false;

        if (!isAuthenticated)
        {
            _hasShownLoginReminder = false;
            ClearAllRatings();
            await InvokeAsync(StateHasChanged);
            return;
        }

        await LoadUserRatings(books);
    }

    private async Task LoadGenresAndAuthors()
    {
        try
        {
            var genresTask = Http.GetFromJsonAsync<List<Genre>>("api/Genre");
            var authorsTask = Http.GetFromJsonAsync<List<Author>>("api/Author");

            await Task.WhenAll(genresTask!, authorsTask!);

            genres = genresTask?.Result ?? new List<Genre>();
            authors = authorsTask?.Result ?? new List<Author>();

            foreach (var genre in genres)
            {
                selectedGenres[genre.GenreId] = false;
            }
        }
        catch
        {
            genres = new List<Genre>();
            authors = new List<Author>();
        }
    }

    private async Task LoadBooks(bool append = false)
    {
        try
        {
            if (!append)
            {
                isLoading = true;
                currentPage = 1;
                books.Clear();
            }
            else
            {
                isLoadingMore = true;
            }

            var selectedGenreIds = selectedGenres.Where(kv => kv.Value).Select(kv => kv.Key).ToList();

            var realBooks = await Http.GetFromJsonAsync<List<Book>>("api/Books") ?? new List<Book>();

            var newBooks = realBooks.Select(book =>
            {
                var imageUrl = book.GetType().GetProperty("ImageUrl")?.GetValue(book)?.ToString();

                return new BookDiscover
                {
                    BookId = book.BookId,
                    Title = book.Title,
                    AuthorId = book.AuthorId,
                    GenreId = book.GenreId,
                    PublishYear = book.PublishYear,
                    Description = book.Description ?? string.Empty,
                    CoverImageUrl = imageUrl,
                    AverageRating = 4.0 + (book.BookId % 10) * 0.1,
                    ReviewCount = 50 + (book.BookId * 7) % 200
                };
            }).ToList();

            if (!string.IsNullOrWhiteSpace(searchQuery))
            {
                newBooks = newBooks.Where(b => b.Title.Contains(searchQuery, StringComparison.OrdinalIgnoreCase)).ToList();
            }

            if (selectedGenreIds.Any())
            {
                newBooks = newBooks.Where(b => selectedGenreIds.Contains(b.GenreId)).ToList();
            }

            if (MinRating > 0)
            {
                newBooks = newBooks.Where(b => b.AverageRating >= MinRating).ToList();
            }

            newBooks = SortOption switch
            {
                "newest" => newBooks.OrderByDescending(b => b.PublishYear).ToList(),
                "rating" => newBooks.OrderByDescending(b => b.AverageRating).ToList(),
                "title" => newBooks.OrderBy(b => b.Title).ToList(),
                _ => newBooks.OrderByDescending(b => b.AverageRating * b.ReviewCount).ToList()
            };

            var skip = (currentPage - 1) * PageSize;
            newBooks = newBooks.Skip(skip).Take(PageSize).ToList();

            if (append)
            {
                books.AddRange(newBooks);
            }
            else
            {
                books = newBooks;
            }

            hasMoreBooks = newBooks.Count == PageSize;
            currentPage++;
            
            // Always load user ratings after books are loaded (if authenticated)
            // This ensures ratings are restored when returning to the page
            if (isAuthenticated)
            {
                if (append)
                {
                    // For append, only load ratings for new books
                    await LoadUserRatings(newBooks);
                }
                else
                {
                    // For initial load, load ratings for all books
                    await LoadUserRatings(books);
                }
            }
        }
        catch
        {
            // swallow for UI; could log to console if needed
        }
        finally
        {
            isLoading = false;
            isLoadingMore = false;
            StateHasChanged();
        }
    }

    private void OnGenreToggled(int genreId, ChangeEventArgs e)
    {
        var isChecked = e.Value is bool b && b;
        selectedGenres[genreId] = isChecked;
        _ = LoadBooks();
    }

    private void OnSearchChanged(ChangeEventArgs e)
    {
        searchQuery = e.Value?.ToString() ?? string.Empty;
        DebounceLoad();
    }

    private void DebounceLoad()
    {
        _debounceTimer?.Stop();
        _debounceTimer?.Dispose();

        _debounceTimer = new System.Timers.Timer(250);
        _debounceTimer.Elapsed += async (_, __) =>
        {
            _debounceTimer?.Stop();
            await InvokeAsync(async () => await LoadBooks());
        };
        _debounceTimer.AutoReset = false;
        _debounceTimer.Start();
    }

    private async Task LoadMoreBooks() => await LoadBooks(append: true);

    private async Task ApplyFilters() => await LoadBooks();

    private async Task HandleAddToList(BookDiscover book)
    {
        // Hook into reading list logic here if needed
        await Task.CompletedTask;
    }

    private string GetAuthorName(int? authorId) => authorId.HasValue
        ? authors.FirstOrDefault(a => a.AuthorId == authorId.Value)?.Name ?? "Unknown"
        : "Unknown";

    private string GetGenreName(int? genreId) => genreId.HasValue
        ? genres.FirstOrDefault(g => g.GenreId == genreId.Value)?.GenreName ?? "Unknown"
        : "Unknown";

    private static string Truncate(string value, int maxLength)
    {
        if (string.IsNullOrWhiteSpace(value)) return string.Empty;
        return value.Length <= maxLength ? value : value.Substring(0, maxLength).TrimEnd() + "...";
    }

    private async Task SetRatingAsync(int bookId, int rating)
    {
        if (!isAuthenticated)
        {
            ShowLoginToast();
            return;
        }

        var normalizedRating = Math.Clamp(rating, 1, 5);
        var previousRating = GetUserRating(bookId);
        Console.WriteLine($"[Discover] SetRatingAsync - BookId: {bookId}, Rating: {normalizedRating}, Previous: {previousRating}");
        
        SetLocalRating(bookId, normalizedRating);
        StateHasChanged();

        var result = await ReviewService.RateBookAsync(bookId, normalizedRating);
        Console.WriteLine($"[Discover] SetRatingAsync result - Success: {result.Success}, IsUnauthorized: {result.IsUnauthorized}, Message: {result.Message}");
        
        if (!result.Success)
        {
            RestoreLocalRating(bookId, previousRating);
            StateHasChanged();

            if (result.IsUnauthorized)
            {
                isAuthenticated = false;
                ClearAllRatings();
                ShowLoginToast();
            }
            else
            {
                ShowRatingToast(result.Message, ToastType.Error);
            }

            return;
        }

        var savedRating = result.Data?.Rating ?? normalizedRating;
        SetLocalRating(bookId, savedRating);
        Console.WriteLine($"[Discover] Rating saved successfully - BookId: {bookId}, Saved Rating: {savedRating}");
        StateHasChanged();
        ShowRatingToast(result.Message, ToastType.Success);
    }

    private async Task LoadUserRatings(IEnumerable<BookDiscover>? sourceBooks)
    {
        if (!isAuthenticated || sourceBooks == null)
        {
            Console.WriteLine($"[Discover] LoadUserRatings skipped - isAuthenticated: {isAuthenticated}, sourceBooks: {sourceBooks != null}");
            return;
        }

        var booksToProcess = sourceBooks.ToList();
        if (!booksToProcess.Any())
        {
            Console.WriteLine("[Discover] LoadUserRatings skipped - no books to process");
            return;
        }

        Console.WriteLine($"[Discover] Loading ratings for {booksToProcess.Count} books");
        var tasks = booksToProcess.Select(b => LoadUserRatingAsync(b.BookId));
        await Task.WhenAll(tasks);
        Console.WriteLine($"[Discover] Finished loading ratings. Current _userRatings count: {_userRatings.Count}");
        await InvokeAsync(StateHasChanged);
    }

    private async Task LoadUserRatingAsync(int bookId)
    {
        try
        {
            var result = await ReviewService.GetUserRatingAsync(bookId);
            
            Console.WriteLine($"[Discover] LoadUserRatingAsync - BookId: {bookId}, Success: {result.Success}, IsUnauthorized: {result.IsUnauthorized}, Data: {(result.Data != null ? $"Rating={result.Data.Rating}, BookId={result.Data.BookId}" : "null")}");
            
            // GetUserRatingAsync now returns success with rating 0 for unauthorized, so we always process the result
            if (result.Success && result.Data != null)
            {
                var rating = result.Data.Rating;
                Console.WriteLine($"[Discover] Processing rating {rating} for book {bookId}");
                if (rating > 0)
                {
                    SetLocalRating(bookId, rating);
                    Console.WriteLine($"[Discover] âœ“ Set rating for book {bookId}: {rating} (Current _userRatings count: {_userRatings.Count})");
                }
                else
                {
                    ClearLocalRating(bookId);
                    Console.WriteLine($"[Discover] Cleared rating for book {bookId} (rating was 0)");
                }
            }
            else if (result.IsUnauthorized)
            {
                // This should rarely happen now since GetUserRatingAsync returns success with rating 0
                // But handle it gracefully if it does
                Console.WriteLine($"[Discover] Unauthorized for book {bookId}");
                isAuthenticated = false;
                ClearLocalRating(bookId);
            }
            else
            {
                // On failure, just clear the rating for this book
                ClearLocalRating(bookId);
                Console.WriteLine($"[Discover] Failed to load rating for book {bookId}: {result.Message}");
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"[Discover] Exception loading rating for book {bookId}: {ex.Message}");
            ClearLocalRating(bookId);
        }
    }

    private int GetUserRating(int bookId)
    {
        lock (_userRatings)
        {
            return _userRatings.TryGetValue(bookId, out var rating) ? rating : 0;
        }
    }

    private void SetLocalRating(int bookId, int rating)
    {
        lock (_userRatings)
        {
            if (rating <= 0)
            {
                _userRatings.Remove(bookId);
            }
            else
            {
                _userRatings[bookId] = rating;
            }
        }
    }

    private void ClearLocalRating(int bookId)
    {
        lock (_userRatings)
        {
            _userRatings.Remove(bookId);
        }
    }

    private void ClearAllRatings()
    {
        lock (_userRatings)
        {
            _userRatings.Clear();
        }
    }

    private void RestoreLocalRating(int bookId, int previousRating)
    {
        if (previousRating > 0)
        {
            SetLocalRating(bookId, previousRating);
        }
        else
        {
            ClearLocalRating(bookId);
        }
    }

    private string GetRatingTooltip(int currentRating)
    {
        if (!isAuthenticated)
        {
            return LoginRequiredMessage;
        }

        return currentRating > 0
            ? $"You rated {currentRating}/5"
            : "Tap a star to rate this book";
    }

    private void ShowLoginToast()
    {
        _hasShownLoginReminder = true;
        ShowRatingToast(LoginRequiredMessage, ToastType.Error);
    }

    private void ShowRatingToast(string message, ToastType type)
    {
        ratingToastMessage = message;
        ratingToastType = type;
        showRatingToast = true;
        StateHasChanged();
    }

    private void HideRatingToast()
    {
        showRatingToast = false;
        ratingToastMessage = null;
        StateHasChanged();
    }

    private string ResolveImageUrl(string? url)
    {
        if (string.IsNullOrWhiteSpace(url))
        {
            return PlaceholderImage;
        }

        if (Uri.TryCreate(url, UriKind.Absolute, out var absolute) &&
            (absolute.Scheme == Uri.UriSchemeHttp || absolute.Scheme == Uri.UriSchemeHttps))
        {
            return absolute.ToString();
        }

        var baseUri = Http.BaseAddress;
        if (baseUri == null || baseUri.Scheme == Uri.UriSchemeFile)
        {
            baseUri = new Uri("http://localhost:5069/");
        }

        try
        {
            return new Uri(baseUri, url.TrimStart('/')).ToString();
        }
        catch
        {
            return PlaceholderImage;
        }
    }

    public void Dispose()
    {
        AuthStateProvider.AuthenticationStateChanged -= HandleAuthenticationStateChanged;
        _debounceTimer?.Stop();
        _debounceTimer?.Dispose();
        _debounceTimer = null;
    }
}
