@page "/discover"
@implements IDisposable
@inject HttpClient Http
@using BookDashboardBlazor.Services
@inject ReviewService ReviewService
@inject ReadingListService ReadingListService
@inject ReadingGoalService ReadingGoalService
@inject AuthenticationStateProvider AuthStateProvider
@inject NavigationManager Nav

<PageTitle>Discover Books</PageTitle>

<style>
    .user-rating .star-rating {
        gap: 0.2rem;
    }

    .user-rating .star-rating .bi {
        font-size: 1.4rem;
        transition: color 0.2s ease;
    }
</style>

<div class="position-fixed top-0 end-0 p-3" style="z-index: 1080;">
    <Toast Visible="showRatingToast"
           Type="ratingToastType"
           Message="@(ratingToastMessage ?? string.Empty)"
           OnClose="HideRatingToast"
           CssClass="shadow" />
    <Toast Visible="showReadingListToast"
           Type="readingListToastType"
           Message="@(readingListToastMessage ?? string.Empty)"
           OnClose="HideReadingListToast"
           CssClass="shadow" />
    <Toast Visible="showGoalToast"
           Type="goalToastType"
           Message="@(goalToastMessage ?? string.Empty)"
           OnClose="HideGoalToast"
           CssClass="shadow" />
</div>

@* Create Reading Goal Modal Component *@
<GoalModal IsVisible="@(showCreateGoalModalForBookId.HasValue)"
           IsVisibleChanged="@(val => { if(!val) CloseGoalModal(); })"
           Mode="GoalModal.GoalModalMode.Create"
           BookId="@showCreateGoalModalForBookId"
           BookTitle="@(showCreateGoalModalForBookId.HasValue ? books.FirstOrDefault(b => b.BookId == showCreateGoalModalForBookId)?.Title : "")"
           IsBookEditable="false"
           OnGoalCreated="HandleGoalCreated" />

@* View/Edit Reading Goal Modal *@
@if (showEditGoalModalForBookId.HasValue)
{
    <div class="modal fade show d-block" tabindex="-1" style="background-color: rgba(0,0,0,0.6);" @onclick="CloseGoalModal">
        <div class="modal-dialog modal-dialog-centered" @onclick:stopPropagation="true">
            <div class="modal-content shadow-lg border-0">
                <div class="modal-header bg-info text-white">
                    <h5 class="modal-title"><i class="bi bi-bullseye me-2"></i>Manage Reading Goal</h5>
                    <button type="button" class="btn-close btn-close-white" @onclick="CloseGoalModal"></button>
                </div>
                <div class="modal-body p-4">
                    <div class="mb-3">
                        <label class="form-label fw-bold">Year</label>
                        <input type="number" class="form-control" @bind="goalModalYear" min="@(DateTime.UtcNow.Year + 1)" />
                        <small class="form-text text-muted">Goal year must be in the future</small>
                    </div>
                    <div class="mb-3">
                        <label class="form-label fw-bold">Goal Percentage</label>
                        <div class="input-group">
                            <input type="number" class="form-control" @bind="goalModalPercentage" min="1" max="100" />
                            <span class="input-group-text">%</span>
                        </div>
                        <small class="form-text text-muted">Target percentage to read</small>
                    </div>
                    <div class="mb-3">
                        <label class="form-label fw-bold">Current Progress</label>
                        <div class="input-group">
                            <input type="number" class="form-control" @bind="goalModalProgress" min="0" max="100" />
                            <span class="input-group-text">%</span>
                        </div>
                        <small class="form-text text-muted">Update your reading progress</small>
                    </div>
                </div>
                <div class="modal-footer d-flex justify-content-between">
                    <button type="button" class="btn btn-danger" @onclick="DeleteGoal">
                        <i class="bi bi-trash me-1"></i> Delete Goal
                    </button>
                    <div>
                        <button type="button" class="btn btn-secondary me-2" @onclick="CloseGoalModal">Cancel</button>
                        <button type="button" class="btn btn-primary" @onclick="UpdateGoal">
                            <i class="bi bi-check-circle me-1"></i> Update Goal
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>
}

<div class="discover-page">
    <div class="container-xxl">
        <!-- Hero / Search -->
        <div class="discover-hero my-4">
            <div class="hero-surface shadow-lg">
                <span class="hero-label">Discover</span>
                <h1 class="hero-title">Discover Books</h1>
                <p class="hero-subtitle">Browse curated titles and filter by genre, rating, or recency.</p>
                <div class="hero-search">
                    <i class="bi bi-search"></i>
                    <input class="form-control hero-input"
                           placeholder="Search by title or author..."
                           value="@searchQuery"
                           @oninput="OnSearchChanged" />
                </div>
            </div>
        </div>

        <div class="row g-4">
            <!-- Filters -->
            <div class="col-12 col-lg-3">
                <div class="card shadow-sm border-0 h-100 sticky-filters">
                    <div class="card-body">
                        <div class="d-flex justify-content-between align-items-center mb-3">
                            <h6 class="mb-0 text-uppercase text-muted fw-semibold small">Filters</h6>
                            <span class="badge bg-light text-secondary border">Live</span>
                        </div>

                        <div class="mb-4">
                            <label class="form-label small fw-semibold text-muted">Genres</label>
                            <div class="d-grid gap-2 filter-list">
                                @if (genres == null || !genres.Any())
                                {
                                    <span class="text-muted small">Loading genres...</span>
                                }
                                else
                                {
                                    @foreach (var genre in genres)
                                    {
                                        <div class="form-check">
                                            <input class="form-check-input" type="checkbox" id="genre-@genre.GenreId"
                                                   checked="@selectedGenres.GetValueOrDefault(genre.GenreId)"
                                                   @onchange="e => OnGenreToggled(genre.GenreId, e)" />
                                            <label class="form-check-label" for="genre-@genre.GenreId">
                                                @genre.GenreName
                                            </label>
                                        </div>
                                    }
                                }
                            </div>
                        </div>

                        <div class="mb-3">
                            <label class="form-label small fw-semibold text-muted">Minimum rating</label>
                            <select class="form-select" @bind="MinRating">
                                <option value="0">Any rating</option>
                                <option value="4">4+ stars</option>
                                <option value="3">3+ stars</option>
                                <option value="2">2+ stars</option>
                                <option value="1">1+ stars</option>
                            </select>
                        </div>

                        <div class="mb-3">
                            <label class="form-label small fw-semibold text-muted">Sort by</label>
                            <select class="form-select" @bind="SortOption">
                                <option value="trending">Trending</option>
                                <option value="newest">Newest</option>
                                <option value="rating">Top rated</option>
                                <option value="title">A-Z</option>
                            </select>
                        </div>

                        <button class="btn btn-primary w-100" @onclick="ApplyFilters">
                            Apply filters
                        </button>
                    </div>
                </div>
            </div>

            <!-- Books grid -->
            <div class="col-12 col-lg-9">
                @if (isLoading)
                {
                    <div class="row g-4 row-cols-1 row-cols-sm-2 row-cols-md-3 row-cols-xl-4">
                        @for (int i = 0; i < 8; i++)
                        {
                            <div class="col">
                                <div class="card h-100 shadow-sm placeholder-card">
                                    <div class="ratio ratio-3x4 placeholder-glow">
                                        <div class="placeholder w-100 h-100"></div>
                                    </div>
                                    <div class="card-body">
                                        <div class="placeholder-glow">
                                            <div class="placeholder col-8 mb-2"></div>
                                            <div class="placeholder col-5 mb-2"></div>
                                            <div class="placeholder col-10 mb-3"></div>
                                            <div class="placeholder col-6"></div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        }
                    </div>
                }
                else if (books == null || !books.Any())
                {
                    <div class="card border-0 shadow-sm text-center p-5">
                        <div class="card-body">
                            <i class="bi bi-search text-muted display-4 mb-3"></i>
                            <h5 class="fw-semibold mb-2">No books found</h5>
                            <p class="text-muted mb-0">Try adjusting your search or filters to see more results.</p>
                        </div>
                    </div>
                }
                else
                {
                    <div class="row g-4 row-cols-1 row-cols-sm-2 row-cols-md-3 row-cols-xl-4">
                        @foreach (var book in books)
                        {
                            <div class="col">
                                <div class="card h-100 shadow-sm book-card">
                                    <div class="ratio ratio-3x4 bg-light position-relative overflow-hidden">
                                        <img src="@ResolveImageUrl(book.CoverImageUrl)"
                                             alt="@book.Title cover"
                                             class="book-cover"
                                             onerror="@ImageErrorFallbackJs"
                                             style="object-fit:cover; width:100%; height:100%; display:block;" />
                                    </div>
                                    <div class="card-body d-flex flex-column">
                                        <div class="d-flex align-items-start justify-content-between gap-2">
                                            <h6 class="mb-1 fw-semibold text-truncate" title="@book.Title">@book.Title</h6>
                                            <span class="badge bg-soft-primary text-primary">@GetGenreName(book.GenreId)</span>
                                        </div>
                                        <p class="text-muted small mb-2">@GetAuthorName(book.AuthorId)</p>
                                        <p class="text-secondary small flex-grow-1 overflow-hidden">
                                            @Truncate(book.Description, 110)
                                        </p>
                                        
                                        @{ var userRating = GetUserRating(book.BookId); }
                                        <div class="user-rating my-2 d-flex justify-content-center align-items-center gap-1 flex-wrap"
                                             style="min-height: 32px;"
                                             title="@GetRatingTooltip(userRating)">
                                            <StarRating Value="@userRating"
                                                        ValueChanged="@((int rating) => SetRatingAsync(book.BookId, rating))" />
                                        </div>

                                        <div class="d-flex gap-2 mt-auto">
                                            @* Reading List Button *@
                                            @if (IsInReadingList(book.BookId))
                                            {
                                                <button class="btn btn-success btn-sm flex-fill" @onclick="() => HandleRemoveFromList(book.BookId)" title="Remove from reading list">
                                                    <i class="bi bi-check-circle-fill me-1"></i> In list
                                                </button>
                                            }
                                            else
                                            {
                                                <button class="btn btn-outline-primary btn-sm flex-fill" @onclick="() => HandleAddToList(book.BookId)" title="Add to reading list">
                                                    <i class="bi bi-plus-circle me-1"></i> Add
                                                </button>
                                            }

                                            @* Reading Goal Button *@
                                            @if (HasGoal(book.BookId))
                                            {
                                                <button class="btn btn-info btn-sm flex-fill text-white" @onclick="() => HandleGoalClick(book.BookId)" title="View/edit goal" style="font-size: 0.75rem; padding: 0.25rem 0.5rem;">
                                                    <i class="bi bi-bullseye" style="font-size: 0.7rem;"></i> @GetGoalLabel(book.BookId)
                                                </button>
                                            }
                                            else
                                            {
                                                <button class="btn btn-outline-secondary btn-sm flex-fill" @onclick="() => HandleGoalClick(book.BookId)" title="Set reading goal" style="font-size: 0.75rem; padding: 0.25rem 0.5rem;">
                                                    <i class="bi bi-bullseye" style="font-size: 0.7rem;"></i> Goal
                                                </button>
                                            }
                                        </div>
                                    </div>
                                </div>
                            </div>
                        }
                    </div>

                    @if (hasMoreBooks)
                    {
                        <div class="text-center mt-4">
                            <button class="btn btn-primary px-4" @onclick="LoadMoreBooks" disabled="@isLoadingMore">
                                @if (isLoadingMore)
                                {
                                    <LoadingSpinner Inline="true" ShowLabel="false" Size="18" CssClass="me-2" />
                                    <span>Loading...</span>
                                }
                                else
                                {
                                    <span>Load more</span>
                                }
                            </button>
                        </div>
                    }
                }
            </div>
        </div>
    </div>
</div>

@code {
    private List<BookDiscover> books = new();
    private List<Author> authors = new();
    private List<Genre> genres = new();
    private Dictionary<int, bool> selectedGenres = new();
    private Dictionary<int, int> _userRatings = new();
    private HashSet<int> readingListBookIds = new();
    private Dictionary<int, ReadingGoalViewModel> userGoals = new();
    private bool isAuthenticated;
    private bool _hasShownLoginReminder;
    private const string LoginRequiredMessage = "Login to rate this book.";
    private const string ReadingListLoginMessage = "Login to save books to your reading list.";
    private const string ReadingGoalLoginMessage = "Login to create reading goals.";
    private const string PlaceholderImage = "/images/book-placeholder.svg";
    private string ImageErrorFallbackJs => $"this.onerror=null; this.src='{PlaceholderImage}';";
    private bool showRatingToast;
    private string? ratingToastMessage;
    private ToastType ratingToastType = ToastType.Success;
    private bool showReadingListToast;
    private string? readingListToastMessage;
    private ToastType readingListToastType = ToastType.Success;
    private bool showGoalToast;
    private string? goalToastMessage;
    private ToastType goalToastType = ToastType.Success;
    private int? showRemoveMenuForBookId = null;
    private int? showCreateGoalModalForBookId = null;
    private int? showEditGoalModalForBookId = null;
    private int goalModalYear;
    private int goalModalPercentage = 50;
    private int goalModalProgress = 0;
    private int? editingGoalId = null;

    private string searchQuery = string.Empty;
    private int _minRating = 0;
    private string _sortOption = "trending";
    private bool isLoading = true;
    private bool isLoadingMore = false;
    private bool hasMoreBooks = true;
    private int currentPage = 1;
    private const int PageSize = 20;
    private System.Timers.Timer? _debounceTimer;

    private int MinRating
    {
        get => _minRating;
        set
        {
            if (_minRating != value)
            {
                _minRating = value;
                _ = LoadBooks();
            }
        }
    }

    private string SortOption
    {
        get => _sortOption;
        set
        {
            if (_sortOption != value)
            {
                _sortOption = value;
                _ = LoadBooks();
            }
        }
    }

    protected override async Task OnInitializedAsync()
    {
        Console.WriteLine("[Discover] ===== OnInitializedAsync called =====");
        AuthStateProvider.AuthenticationStateChanged += HandleAuthenticationStateChanged;

        var authState = await AuthStateProvider.GetAuthenticationStateAsync();
        isAuthenticated = authState.User.Identity?.IsAuthenticated ?? false;
        Console.WriteLine($"[Discover] OnInitializedAsync - isAuthenticated: {isAuthenticated}");

        await LoadGenresAndAuthors();
        await LoadBooks();
        
        // Ensure user ratings, reading list, and goals are loaded after books are loaded
        if (isAuthenticated && books.Any())
        {
            await LoadUserRatings(books);
            await LoadUserReadingList();
            await LoadUserGoals();
        }
    }

    protected override async Task OnParametersSetAsync()
    {
        Console.WriteLine("[Discover] ===== OnParametersSetAsync called =====");
        // Handle navigation back to the page
        var authState = await AuthStateProvider.GetAuthenticationStateAsync();
        var wasAuthenticated = isAuthenticated;
        isAuthenticated = authState.User.Identity?.IsAuthenticated ?? false;
        Console.WriteLine($"[Discover] OnParametersSetAsync - isAuthenticated: {isAuthenticated}, wasAuthenticated: {wasAuthenticated}");

        // If user logged out, clear ratings and reading list
        if (!isAuthenticated && wasAuthenticated)
        {
            Console.WriteLine("[Discover] User logged out, clearing state");
            ClearAllRatings();
            readingListBookIds.Clear();
            await InvokeAsync(StateHasChanged);
            return;
        }

        // If user is authenticated, always reload reading list to ensure it's current
        if (isAuthenticated)
        {
            Console.WriteLine($"[Discover] User authenticated, books count: {books.Count}, isLoading: {isLoading}");
            // If books haven't been loaded yet, load them first (this will also load reading list)
            if (!books.Any() && !isLoading)
            {
                Console.WriteLine("[Discover] Loading books (which will load reading list)");
                await LoadBooks();
            }
            // If books are already loaded, reload ratings and reading list to ensure they're current
            else if (books.Any())
            {
                Console.WriteLine("[Discover] Books already loaded, reloading ratings, reading list, and goals");
                await LoadUserRatings(books);
                await LoadUserReadingList();
                await LoadUserGoals();
            }
        }
    }

    private async void HandleAuthenticationStateChanged(Task<AuthenticationState> task)
    {
        var authState = await task;
        var newIsAuthenticated = authState.User.Identity?.IsAuthenticated ?? false;

        if (newIsAuthenticated == isAuthenticated)
        {
            return;
        }

        isAuthenticated = newIsAuthenticated;
        _hasShownLoginReminder = false;

        if (!isAuthenticated)
        {
            _hasShownLoginReminder = false;
            ClearAllRatings();
            readingListBookIds.Clear();
            userGoals.Clear();
            await InvokeAsync(StateHasChanged);
            return;
        }

        await LoadUserRatings(books);
        await LoadUserReadingList();
        await LoadUserGoals();
    }

    private async Task LoadGenresAndAuthors()
    {
        try
        {
            var genresTask = Http.GetFromJsonAsync<List<Genre>>("api/Genre");
            var authorsTask = Http.GetFromJsonAsync<List<Author>>("api/Author");

            await Task.WhenAll(genresTask!, authorsTask!);

            genres = genresTask?.Result ?? new List<Genre>();
            authors = authorsTask?.Result ?? new List<Author>();

            foreach (var genre in genres)
            {
                selectedGenres[genre.GenreId] = false;
            }
        }
        catch
        {
            genres = new List<Genre>();
            authors = new List<Author>();
        }
    }

    private async Task LoadBooks(bool append = false)
    {
        try
        {
            if (!append)
            {
                isLoading = true;
                currentPage = 1;
                books.Clear();
            }
            else
            {
                isLoadingMore = true;
            }

            var selectedGenreIds = selectedGenres.Where(kv => kv.Value).Select(kv => kv.Key).ToList();

            var realBooks = await Http.GetFromJsonAsync<List<Book>>("api/Books") ?? new List<Book>();

            var newBooks = realBooks.Select(book =>
            {
                var imageUrl = book.GetType().GetProperty("ImageUrl")?.GetValue(book)?.ToString();

                return new BookDiscover
                {
                    BookId = book.BookId,
                    Title = book.Title,
                    AuthorId = book.AuthorId,
                    GenreId = book.GenreId,
                    PublishYear = book.PublishYear,
                    Description = book.Description ?? string.Empty,
                    CoverImageUrl = imageUrl,
                    AverageRating = 4.0 + (book.BookId % 10) * 0.1,
                    ReviewCount = 50 + (book.BookId * 7) % 200
                };
            }).ToList();

            if (!string.IsNullOrWhiteSpace(searchQuery))
            {
                newBooks = newBooks.Where(b => b.Title.Contains(searchQuery, StringComparison.OrdinalIgnoreCase)).ToList();
            }

            if (selectedGenreIds.Any())
            {
                newBooks = newBooks.Where(b => selectedGenreIds.Contains(b.GenreId)).ToList();
            }

            if (MinRating > 0)
            {
                newBooks = newBooks.Where(b => b.AverageRating >= MinRating).ToList();
            }

            newBooks = SortOption switch
            {
                "newest" => newBooks.OrderByDescending(b => b.PublishYear).ToList(),
                "rating" => newBooks.OrderByDescending(b => b.AverageRating).ToList(),
                "title" => newBooks.OrderBy(b => b.Title).ToList(),
                _ => newBooks.OrderByDescending(b => b.AverageRating * b.ReviewCount).ToList()
            };

            var skip = (currentPage - 1) * PageSize;
            newBooks = newBooks.Skip(skip).Take(PageSize).ToList();

            if (append)
            {
                books.AddRange(newBooks);
            }
            else
            {
                books = newBooks;
            }

            hasMoreBooks = newBooks.Count == PageSize;
            currentPage++;
            
            // Always load user ratings AND reading list after books are loaded (if authenticated)
            // This ensures both are restored when returning to the page
            if (isAuthenticated)
            {
                if (append)
                {
                    // For append, only load ratings for new books
                    await LoadUserRatings(newBooks);
                    // Reading list doesn't change with "load more", so no need to reload it
                }
                else
                {
                    // For initial load, load ratings for all books AND reading list AND goals
                    Console.WriteLine("[Discover] LoadBooks - loading user ratings, reading list, and goals");
                    await LoadUserRatings(books);
                    await LoadUserReadingList();
                    await LoadUserGoals();
                }
            }
            else
            {
                // User not authenticated, clear reading list and goals
                Console.WriteLine("[Discover] LoadBooks - user not authenticated, clearing reading list and goals");
                readingListBookIds.Clear();
                userGoals.Clear();
            }
        }
        catch
        {
            // swallow for UI; could log to console if needed
        }
        finally
        {
            isLoading = false;
            isLoadingMore = false;
            StateHasChanged();
        }
    }

    private void OnGenreToggled(int genreId, ChangeEventArgs e)
    {
        var isChecked = e.Value is bool b && b;
        selectedGenres[genreId] = isChecked;
        _ = LoadBooks();
    }

    private void OnSearchChanged(ChangeEventArgs e)
    {
        searchQuery = e.Value?.ToString() ?? string.Empty;
        DebounceLoad();
    }

    private void DebounceLoad()
    {
        _debounceTimer?.Stop();
        _debounceTimer?.Dispose();

        _debounceTimer = new System.Timers.Timer(250);
        _debounceTimer.Elapsed += async (_, __) =>
        {
            _debounceTimer?.Stop();
            await InvokeAsync(async () => await LoadBooks());
        };
        _debounceTimer.AutoReset = false;
        _debounceTimer.Start();
    }

    private async Task LoadMoreBooks() => await LoadBooks(append: true);

    private async Task ApplyFilters() => await LoadBooks();

    // ============================================================================
    // READING LIST METHODS
    // ============================================================================

    private async Task LoadUserReadingList()
    {
        Console.WriteLine($"[Discover] LoadUserReadingList called - isAuthenticated: {isAuthenticated}");
        
        if (!isAuthenticated)
        {
            Console.WriteLine("[Discover] User not authenticated, clearing reading list");
            readingListBookIds.Clear();
            return;
        }

        try
        {
            Console.WriteLine("[Discover] Calling ReadingListService.GetUserList()...");
            var bookIds = await ReadingListService.GetUserList();
            readingListBookIds = bookIds;
            Console.WriteLine($"[Discover] ✅ Successfully loaded reading list with {readingListBookIds.Count} books: [{string.Join(", ", readingListBookIds)}]");
            await InvokeAsync(StateHasChanged);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"[Discover] ❌ Error loading reading list: {ex.Message}");
            Console.WriteLine($"[Discover] Stack trace: {ex.StackTrace}");
            readingListBookIds.Clear();
        }
    }

    private bool IsInReadingList(int bookId)
    {
        var isInList = readingListBookIds.Contains(bookId);
        // Uncomment for detailed debugging of each book card render
        // Console.WriteLine($"[Discover] IsInReadingList({bookId}) = {isInList}");
        return isInList;
    }

    private async Task HandleAddToList(int bookId)
    {
        Console.WriteLine($"[Discover] HandleAddToList called for bookId: {bookId}");
        
        if (!isAuthenticated)
        {
            Console.WriteLine($"[Discover] User not authenticated, showing login message");
            ShowReadingListToast(ReadingListLoginMessage, ToastType.Error);
            return;
        }

        Console.WriteLine($"[Discover] Calling ReadingListService.AddToList({bookId})...");
        var success = await ReadingListService.AddToList(bookId);
        if (success)
        {
            readingListBookIds.Add(bookId);
            Console.WriteLine($"[Discover] ✅ Book {bookId} added to reading list. Total books in list: {readingListBookIds.Count}");
            ShowReadingListToast("Book added to your reading list!", ToastType.Success);
            StateHasChanged();
        }
        else
        {
            Console.WriteLine($"[Discover] ❌ Failed to add book {bookId} to reading list");
            ShowReadingListToast("Failed to add book to reading list.", ToastType.Error);
        }
    }

    private void ShowRemoveMenu(int bookId)
    {
        showRemoveMenuForBookId = bookId;
        StateHasChanged();
    }

    private void HideRemoveMenu()
    {
        showRemoveMenuForBookId = null;
        StateHasChanged();
    }

    private async Task HandleRemoveFromList(int bookId)
    {
        Console.WriteLine($"[Discover] HandleRemoveFromList called for bookId: {bookId}");
        showRemoveMenuForBookId = null;
        
        Console.WriteLine($"[Discover] Calling ReadingListService.RemoveFromList({bookId})...");
        var success = await ReadingListService.RemoveFromList(bookId);
        if (success)
        {
            readingListBookIds.Remove(bookId);
            Console.WriteLine($"[Discover] ✅ Book {bookId} removed from reading list. Total books in list: {readingListBookIds.Count}");
            ShowReadingListToast("Book removed from your reading list.", ToastType.Success);
            StateHasChanged();
        }
        else
        {
            Console.WriteLine($"[Discover] ❌ Failed to remove book {bookId} from reading list");
            ShowReadingListToast("Failed to remove book from reading list.", ToastType.Error);
        }
    }

    // ============================================================================
    // READING GOAL METHODS
    // ============================================================================

    private async Task LoadUserGoals()
    {
        Console.WriteLine($"[Discover] LoadUserGoals called - isAuthenticated: {isAuthenticated}");
        
        if (!isAuthenticated)
        {
            Console.WriteLine("[Discover] User not authenticated, clearing goals");
            userGoals.Clear();
            return;
        }

        try
        {
            Console.WriteLine("[Discover] Calling ReadingGoalService.GetUserGoalsAsync()...");
            var goals = await ReadingGoalService.GetUserGoalsAsync();
            userGoals = goals;
            Console.WriteLine($"[Discover] ✅ Successfully loaded {userGoals.Count} reading goals");
            await InvokeAsync(StateHasChanged);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"[Discover] ❌ Error loading reading goals: {ex.Message}");
            userGoals.Clear();
        }
    }

    private bool HasGoal(int bookId)
    {
        return userGoals.ContainsKey(bookId);
    }

    private string GetGoalLabel(int bookId)
    {
        if (userGoals.TryGetValue(bookId, out var goal))
        {
            // Compact format: "26·30%" (short year, no spaces)
            var shortYear = goal.Year.ToString().Substring(2);
            return $"{shortYear}·{goal.Progress}%";
        }
        return "Goal";
    }

    private void HandleGoalClick(int bookId)
    {
        Console.WriteLine($"[Discover] HandleGoalClick for bookId: {bookId}");
        
        if (!isAuthenticated)
        {
            Console.WriteLine("[Discover] User not authenticated, showing login message");
            ShowGoalToast("Login to manage goals for this book.", ToastType.Error);
            return;
        }

        // Check if goal exists for this book
        if (userGoals.TryGetValue(bookId, out var existingGoal))
        {
            // Edit mode
            Console.WriteLine($"[Discover] Opening edit modal for existing goal");
            showEditGoalModalForBookId = bookId;
            goalModalYear = existingGoal.Year;
            goalModalPercentage = existingGoal.GoalPercentage;
            goalModalProgress = existingGoal.Progress;
            editingGoalId = existingGoal.Id;
        }
        else
        {
            // Create mode
            Console.WriteLine($"[Discover] Opening create goal modal for book {bookId}");
            showCreateGoalModalForBookId = bookId;
            goalModalYear = DateTime.UtcNow.Year + 1;
            goalModalPercentage = 50;
            goalModalProgress = 0;
            editingGoalId = null;
        }
        
        StateHasChanged();
    }

    private void CloseGoalModal()
    {
        showCreateGoalModalForBookId = null;
        showEditGoalModalForBookId = null;
        goalModalYear = DateTime.UtcNow.Year + 1;
        goalModalPercentage = 50;
        goalModalProgress = 0;
        editingGoalId = null;
        StateHasChanged();
    }

    private async Task HandleGoalCreated()
    {
        ShowGoalToast("Reading goal created successfully!", ToastType.Success);
        
        // Refresh goals to update UI
        await LoadUserGoals();
        
        // Close modal
        CloseGoalModal();
    }

    private async Task UpdateGoal()
    {
        if (!showEditGoalModalForBookId.HasValue || !editingGoalId.HasValue)
            return;

        var bookId = showEditGoalModalForBookId.Value;
        
        // Client-side validation
        var currentYear = DateTime.UtcNow.Year;
        if (goalModalYear <= currentYear)
        {
            ShowGoalToast("Goal year must be in the future.", ToastType.Error);
            return;
        }

        if (goalModalPercentage < 1 || goalModalPercentage > 100)
        {
            ShowGoalToast("Goal percentage must be between 1% and 100%.", ToastType.Error);
            return;
        }

        if (goalModalProgress < 0 || goalModalProgress > 100)
        {
            ShowGoalToast("Progress must be between 0% and 100%.", ToastType.Error);
            return;
        }

        if (goalModalProgress > goalModalPercentage)
        {
            ShowGoalToast("Progress cannot exceed the goal percentage.", ToastType.Error);
            return;
        }

        Console.WriteLine($"[Discover] Updating goal ID {editingGoalId.Value} for book {bookId}");
        var result = await ReadingGoalService.UpdateGoalAsync(editingGoalId.Value, bookId, goalModalYear, goalModalPercentage, goalModalProgress);

        if (result != null && result.Code != "ERROR" && result.Code != "UNAUTHORIZED" && result.Code != "EXCEPTION")
        {
            // Reload goals from backend
            await LoadUserGoals();
            CloseGoalModal();
            ShowGoalToast("Goal updated successfully!", ToastType.Success);
        }
        else if (result?.Code == "UNAUTHORIZED")
        {
            ShowGoalToast("Login to update goals.", ToastType.Error);
        }
        else
        {
            ShowGoalToast(result?.Message ?? "Failed to update goal. Please try again.", ToastType.Error);
        }
    }

    private async Task DeleteGoal()
    {
        if (!showEditGoalModalForBookId.HasValue || !editingGoalId.HasValue)
            return;

        Console.WriteLine($"[Discover] Deleting goal ID {editingGoalId.Value}");
        var result = await ReadingGoalService.DeleteGoalAsync(editingGoalId.Value);

        if (result != null && result.Code != "ERROR" && result.Code != "UNAUTHORIZED" && result.Code != "EXCEPTION")
        {
            // Reload goals from backend
            await LoadUserGoals();
            CloseGoalModal();
            ShowGoalToast("Goal deleted successfully.", ToastType.Success);
        }
        else if (result?.Code == "UNAUTHORIZED")
        {
            ShowGoalToast("Login to delete goals.", ToastType.Error);
        }
        else
        {
            ShowGoalToast(result?.Message ?? "Failed to delete goal. Please try again.", ToastType.Error);
        }
    }

    private string GetAuthorName(int? authorId) => authorId.HasValue
        ? authors.FirstOrDefault(a => a.AuthorId == authorId.Value)?.Name ?? "Unknown"
        : "Unknown";

    private string GetGenreName(int? genreId) => genreId.HasValue
        ? genres.FirstOrDefault(g => g.GenreId == genreId.Value)?.GenreName ?? "Unknown"
        : "Unknown";

    private static string Truncate(string value, int maxLength)
    {
        if (string.IsNullOrWhiteSpace(value)) return string.Empty;
        return value.Length <= maxLength ? value : value.Substring(0, maxLength).TrimEnd() + "...";
    }

    private async Task SetRatingAsync(int bookId, int rating)
    {
        if (!isAuthenticated)
        {
            ShowLoginToast();
            return;
        }

        var normalizedRating = Math.Clamp(rating, 1, 5);
        var previousRating = GetUserRating(bookId);
        Console.WriteLine($"[Discover] SetRatingAsync - BookId: {bookId}, Rating: {normalizedRating}, Previous: {previousRating}");
        
        SetLocalRating(bookId, normalizedRating);
        StateHasChanged();

        var result = await ReviewService.RateBookAsync(bookId, normalizedRating);
        Console.WriteLine($"[Discover] SetRatingAsync result - Success: {result.Success}, IsUnauthorized: {result.IsUnauthorized}, Message: {result.Message}");
        
        if (!result.Success)
        {
            RestoreLocalRating(bookId, previousRating);
            StateHasChanged();

            if (result.IsUnauthorized)
            {
                isAuthenticated = false;
                ClearAllRatings();
                ShowLoginToast();
            }
            else
            {
                ShowRatingToast(result.Message, ToastType.Error);
            }

            return;
        }

        var savedRating = result.Data?.Rating ?? normalizedRating;
        SetLocalRating(bookId, savedRating);
        Console.WriteLine($"[Discover] Rating saved successfully - BookId: {bookId}, Saved Rating: {savedRating}");
        StateHasChanged();
        ShowRatingToast(result.Message, ToastType.Success);
    }

    private async Task LoadUserRatings(IEnumerable<BookDiscover>? sourceBooks)
    {
        if (!isAuthenticated || sourceBooks == null)
        {
            Console.WriteLine($"[Discover] LoadUserRatings skipped - isAuthenticated: {isAuthenticated}, sourceBooks: {sourceBooks != null}");
            return;
        }

        var booksToProcess = sourceBooks.ToList();
        if (!booksToProcess.Any())
        {
            Console.WriteLine("[Discover] LoadUserRatings skipped - no books to process");
            return;
        }

        Console.WriteLine($"[Discover] Loading ratings for {booksToProcess.Count} books");
        var tasks = booksToProcess.Select(b => LoadUserRatingAsync(b.BookId));
        await Task.WhenAll(tasks);
        Console.WriteLine($"[Discover] Finished loading ratings. Current _userRatings count: {_userRatings.Count}");
        await InvokeAsync(StateHasChanged);
    }

    private async Task LoadUserRatingAsync(int bookId)
    {
        try
        {
            var result = await ReviewService.GetUserRatingAsync(bookId);
            
            Console.WriteLine($"[Discover] LoadUserRatingAsync - BookId: {bookId}, Success: {result.Success}, IsUnauthorized: {result.IsUnauthorized}, Data: {(result.Data != null ? $"Rating={result.Data.Rating}, BookId={result.Data.BookId}" : "null")}");
            
            // GetUserRatingAsync now returns success with rating 0 for unauthorized, so we always process the result
            if (result.Success && result.Data != null)
            {
                var rating = result.Data.Rating;
                Console.WriteLine($"[Discover] Processing rating {rating} for book {bookId}");
                if (rating > 0)
                {
                    SetLocalRating(bookId, rating);
                    Console.WriteLine($"[Discover] ✓ Set rating for book {bookId}: {rating} (Current _userRatings count: {_userRatings.Count})");
                }
                else
                {
                    ClearLocalRating(bookId);
                    Console.WriteLine($"[Discover] Cleared rating for book {bookId} (rating was 0)");
                }
            }
            else if (result.IsUnauthorized)
            {
                // This should rarely happen now since GetUserRatingAsync returns success with rating 0
                // But handle it gracefully if it does
                Console.WriteLine($"[Discover] Unauthorized for book {bookId}");
                isAuthenticated = false;
                ClearLocalRating(bookId);
            }
            else
            {
                // On failure, just clear the rating for this book
                ClearLocalRating(bookId);
                Console.WriteLine($"[Discover] Failed to load rating for book {bookId}: {result.Message}");
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"[Discover] Exception loading rating for book {bookId}: {ex.Message}");
            ClearLocalRating(bookId);
        }
    }

    private int GetUserRating(int bookId)
    {
        lock (_userRatings)
        {
            return _userRatings.TryGetValue(bookId, out var rating) ? rating : 0;
        }
    }

    private void SetLocalRating(int bookId, int rating)
    {
        lock (_userRatings)
        {
            if (rating <= 0)
            {
                _userRatings.Remove(bookId);
            }
            else
            {
                _userRatings[bookId] = rating;
            }
        }
    }

    private void ClearLocalRating(int bookId)
    {
        lock (_userRatings)
        {
            _userRatings.Remove(bookId);
        }
    }

    private void ClearAllRatings()
    {
        lock (_userRatings)
        {
            _userRatings.Clear();
        }
    }

    private void RestoreLocalRating(int bookId, int previousRating)
    {
        if (previousRating > 0)
        {
            SetLocalRating(bookId, previousRating);
        }
        else
        {
            ClearLocalRating(bookId);
        }
    }

    private string GetRatingTooltip(int currentRating)
    {
        if (!isAuthenticated)
        {
            return LoginRequiredMessage;
        }

        return currentRating > 0
            ? $"You rated {currentRating}/5"
            : "Tap a star to rate this book";
    }

    private void ShowLoginToast()
    {
        _hasShownLoginReminder = true;
        ShowRatingToast(LoginRequiredMessage, ToastType.Error);
    }

    private void ShowRatingToast(string message, ToastType type)
    {
        ratingToastMessage = message;
        ratingToastType = type;
        showRatingToast = true;
        StateHasChanged();
    }

    private void HideRatingToast()
    {
        showRatingToast = false;
        ratingToastMessage = null;
        StateHasChanged();
    }

    private void ShowReadingListToast(string message, ToastType type)
    {
        readingListToastMessage = message;
        readingListToastType = type;
        showReadingListToast = true;
        StateHasChanged();
    }

    private void HideReadingListToast()
    {
        showReadingListToast = false;
        readingListToastMessage = null;
        StateHasChanged();
    }

    private void ShowGoalToast(string message, ToastType type)
    {
        goalToastMessage = message;
        goalToastType = type;
        showGoalToast = true;
        StateHasChanged();
    }

    private void HideGoalToast()
    {
        showGoalToast = false;
        goalToastMessage = null;
        StateHasChanged();
    }

    private string ResolveImageUrl(string? url)
    {
        if (string.IsNullOrWhiteSpace(url))
        {
            return PlaceholderImage;
        }

        if (Uri.TryCreate(url, UriKind.Absolute, out var absolute) &&
            (absolute.Scheme == Uri.UriSchemeHttp || absolute.Scheme == Uri.UriSchemeHttps))
        {
            return absolute.ToString();
        }

        var baseUri = Http.BaseAddress;
        if (baseUri == null || baseUri.Scheme == Uri.UriSchemeFile)
        {
            baseUri = new Uri("http://localhost:5069/");
        }

        try
        {
            return new Uri(baseUri, url.TrimStart('/')).ToString();
        }
        catch
        {
            return PlaceholderImage;
        }
    }

    public void Dispose()
    {
        AuthStateProvider.AuthenticationStateChanged -= HandleAuthenticationStateChanged;
        _debounceTimer?.Stop();
        _debounceTimer?.Dispose();
        _debounceTimer = null;
    }
}
